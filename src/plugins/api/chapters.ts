import { Elysia, t } from "elysia";
import { mkdir, writeFile, rm, copyFile } from "node:fs/promises";
import { join, extname } from "node:path";
import { unzipSync } from "fflate";
import { ChapterStore } from "../../stores/chapter-store";
import { PageStore } from "../../stores/page-store";
import { SeriesStore } from "../../stores/series-store";
import { envConfig } from "../../env-config";
import { catchError, catchErrorSync } from "../../lib/error-handler";
import { generateUniqueFilename } from "./helpers";

/**
 * Chapters API endpoints
 */
export const chaptersApi = new Elysia({ prefix: "/chapters" })
  .get("/:slug", async ({ params }) => {
    const [error, chapter] = await catchError(
      ChapterStore.findBySlug(params.slug),
    );

    if (error) {
      console.error("Get chapter error:", error);
      return {
        success: false,
        error: error.message,
      };
    }

    if (!chapter) {
      return {
        success: false,
        error: "Chapter not found",
      };
    }

    return {
      success: true,
      chapter,
    };
  })
  .get("/:slug/pages", async ({ params }) => {
    // Find chapter by slug first
    const [chapterError, chapter] = await catchError(
      ChapterStore.findBySlug(params.slug),
    );

    if (chapterError) {
      console.error("Get chapter error:", chapterError);
      return {
        success: false,
        error: chapterError.message,
        pages: [],
      };
    }

    if (!chapter) {
      return {
        success: false,
        error: "Chapter not found",
        pages: [],
      };
    }

    const [pagesError, pages] = await catchError(
      PageStore.findByChapterId(chapter.id),
    );

    if (pagesError) {
      console.error("Get chapter pages error:", pagesError);
      return {
        success: false,
        error: pagesError.message,
        pages: [],
      };
    }

    return {
      success: true,
      pages,
    };
  })
  .post(
    "/",
    async ({ body }) => {
      const { seriesId: seriesIdStr, title, chapterNumber, zipFile } = body;
      const seriesId = parseInt(seriesIdStr);

      // Check if chapter number already exists for this series
      const [chaptersError, existingChapters] = await catchError(
        ChapterStore.findBySeriesId(seriesId),
      );

      if (chaptersError) {
        console.error("Find chapters error:", chaptersError);
        return {
          success: false,
          error: chaptersError.message,
        };
      }

      if (existingChapters.some((ch) => ch.chapterNumber === chapterNumber)) {
        return {
          success: false,
          error: `Chapter ${chapterNumber} already exists in this series`,
        };
      }

      // Create chapter (slug will be auto-generated by ChapterStore)
      const [createError, chapter] = await catchError(
        ChapterStore.create({
          seriesId,
          title,
          chapterNumber,
        }),
      );

      if (createError) {
        console.error("Create chapter error:", createError);
        return {
          success: false,
          error: createError.message,
        };
      }

      // Create chapter directory
      const chapterDir = join(
        envConfig.MANGA_DIR,
        seriesId.toString(),
        "chapters",
        chapter.id.toString(),
      );

      const [mkdirError] = await catchError(
        mkdir(chapterDir, { recursive: true }),
      );

      if (mkdirError) {
        console.error("Create directory error:", mkdirError);
        return {
          success: false,
          error: mkdirError.message,
        };
      }

      // Extract ZIP file
      const [zipError, zipBuffer] = await catchError(zipFile.arrayBuffer());

      if (zipError) {
        console.error("Read ZIP error:", zipError);
        return {
          success: false,
          error: zipError.message,
        };
      }

      const [unzipError, extracted] = catchErrorSync(() =>
        unzipSync(new Uint8Array(zipBuffer)),
      );

      if (unzipError) {
        console.error("Unzip error:", unzipError);
        return {
          success: false,
          error: unzipError.message,
        };
      }

      // Filter and sort image files
      const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp"];
      const imageFiles: Array<{ name: string; data: Uint8Array }> = [];

      for (const [filename, data] of Object.entries(extracted)) {
        const ext = extname(filename).toLowerCase();
        if (imageExtensions.includes(ext)) {
          imageFiles.push({ name: filename, data: data as Uint8Array });
        }
      }

      // Sort images by filename (natural sort)
      imageFiles.sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { numeric: true }),
      );

      if (imageFiles.length === 0) {
        // Delete chapter if no images found
        await catchError(ChapterStore.delete(chapter.id));
        return {
          success: false,
          error: "No valid image files found in ZIP",
        };
      }

      // Save images and create page records
      const pages = [];
      for (let i = 0; i < imageFiles.length; i++) {
        const imageFile = imageFiles[i];
        if (!imageFile) continue;

        const ext = extname(imageFile.name).replace(".", ""); // Remove leading dot
        const pageFilename = generateUniqueFilename(ext, i + 1);
        const pagePath = join(chapterDir, pageFilename);

        // Write image file
        const [writeError] = await catchError(
          writeFile(pagePath, imageFile.data),
        );

        if (writeError) {
          console.error("Write image error:", writeError);
          return {
            success: false,
            error: writeError.message,
          };
        }

        // Create page record
        const imagePath = `/uploads/${seriesId}/chapters/${chapter.id}/${pageFilename}`;
        const [pageError, page] = await catchError(
          PageStore.create({
            chapterId: chapter.id,
            originalImage: imagePath,
            orderNum: i + 1,
          }),
        );

        if (pageError) {
          console.error("Create page error:", pageError);
          return {
            success: false,
            error: pageError.message,
          };
        }

        pages.push(page);
      }

      // Promote first page as series cover art if series has no cover
      const [seriesError, seriesData] = await catchError(
        SeriesStore.findById(seriesId),
      );

      if (!seriesError && seriesData && !seriesData.coverArt && pages.length > 0) {
        const firstPage = pages[0];
        if (firstPage) {
          // Create series covers directory
          const coversDir = join(
            envConfig.MANGA_DIR,
            seriesId.toString(),
            "covers",
          );

          const [coverDirError] = await catchError(
            mkdir(coversDir, { recursive: true }),
          );

          if (!coverDirError) {
            // Copy first page to covers directory
            const sourcePath = join(
              envConfig.MANGA_DIR,
              firstPage.originalImage.replace("/uploads/", ""),
            );
            const ext = extname(firstPage.originalImage);
            const coverFilename = `cover${ext}`;
            const coverPath = join(coversDir, coverFilename);

            const [copyError] = await catchError(
              copyFile(sourcePath, coverPath),
            );

            if (!copyError) {
              // Update series with cover art path
              const coverArtPath = `/uploads/${seriesId}/covers/${coverFilename}`;
              await catchError(
                SeriesStore.update(seriesId, { coverArt: coverArtPath }),
              );
              console.log(`✅ Set series cover art from first page: ${coverArtPath}`);
            }
          }
        }
      }

      return {
        success: true,
        chapter,
        pagesCount: pages.length,
      };
    },
    {
      body: t.Object({
        seriesId: t.String(), // FormData sends as string
        title: t.String(),
        chapterNumber: t.String(),
        zipFile: t.File(),
      }),
    },
  )
  .put(
    "/:slug",
    async ({ params, body }) => {
      // Find chapter by slug first
      const [findError, chapter] = await catchError(
        ChapterStore.findBySlug(params.slug),
      );

      if (findError) {
        console.error("Find chapter error:", findError);
        return {
          success: false,
          error: findError.message,
        };
      }

      if (!chapter) {
        return {
          success: false,
          error: "Chapter not found",
        };
      }

      const { title, chapterNumber } = body;

      const [updateError, updatedChapter] = await catchError(
        ChapterStore.update(chapter.id, {
          title,
          chapterNumber,
        }),
      );

      if (updateError) {
        console.error("Update chapter error:", updateError);
        return {
          success: false,
          error: updateError.message,
        };
      }

      if (!updatedChapter) {
        return {
          success: false,
          error: "Chapter not found",
        };
      }

      return {
        success: true,
        chapter: updatedChapter,
      };
    },
    {
      body: t.Object({
        title: t.String(),
        chapterNumber: t.String(),
      }),
    },
  )
  .delete("/:slug", async ({ params }) => {
    // Find chapter by slug first
    const [findError, chapter] = await catchError(
      ChapterStore.findBySlug(params.slug),
    );

    if (findError) {
      console.error("Find chapter error:", findError);
      return {
        success: false,
        error: findError.message,
      };
    }

    if (!chapter) {
      return {
        success: false,
        error: "Chapter not found",
      };
    }

    // Delete chapter folder and all its contents
    const chapterDir = join(
      envConfig.MANGA_DIR,
      chapter.seriesId.toString(),
      "chapters",
      chapter.id.toString(),
    );
    const [dirError] = await catchError(
      rm(chapterDir, { recursive: true, force: true }),
    );

    if (dirError) {
      // Folder might not exist, log but don't fail the deletion
      console.warn(
        `⚠️  Could not delete chapter folder for chapter ${chapter.id}`,
        dirError,
      );
    }

    // Delete database record (cascades to pages and captions)
    const [deleteError, deleted] = await catchError(
      ChapterStore.delete(chapter.id),
    );

    if (deleteError) {
      console.error("Delete chapter error:", deleteError);
      return {
        success: false,
        error: deleteError.message,
      };
    }

    if (!deleted) {
      return {
        success: false,
        error: "Failed to delete chapter",
      };
    }

    return {
      success: true,
    };
  })
  .post("/:slug/download-zip", async ({ params }) => {
    // Find chapter by slug
    const [chapterError, chapter] = await catchError(
      ChapterStore.findBySlug(params.slug)
    );

    if (chapterError || !chapter) {
      return new Response("Chapter not found", { status: 404 });
    }

    // Get all pages for the chapter
    const [pagesError, pages] = await catchError(
      PageStore.findByChapterId(chapter.id)
    );

    if (pagesError || !pages || pages.length === 0) {
      return new Response("No pages found", { status: 404 });
    }

    // Create archive object with all page images
    const archiveFiles: Record<string, Uint8Array> = {};

    for (const page of pages) {
      const imagePath = join(
        envConfig.MANGA_DIR,
        page.originalImage.replace("/uploads/", "")
      );

      // Read file as bytes
      const [fileError, fileBuffer] = await catchError(
        Bun.file(imagePath).arrayBuffer()
      );

      if (fileError) {
        console.warn(`Failed to read page ${page.id}:`, fileError);
        continue;
      }

      // Use page number and original extension for filename
      const ext = extname(page.originalImage);
      const filename = `${String(page.orderNum).padStart(3, "0")}${ext}`;
      archiveFiles[filename] = new Uint8Array(fileBuffer);
    }

    if (Object.keys(archiveFiles).length === 0) {
      return new Response("No pages could be read", { status: 500 });
    }

    // Create compressed tar.gz archive using Bun.Archive
    const archive = new Bun.Archive(archiveFiles, {
      compress: "gzip",
      level: 6,
    });

    // Get archive as blob
    const blob = await archive.blob();

    // Return with proper headers for download
    return new Response(blob, {
      headers: {
        "Content-Type": "application/gzip",
        "Content-Disposition": `attachment; filename="${chapter.title}.tar.gz"`,
      },
    });
  });
