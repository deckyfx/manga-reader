import { Elysia, t } from "elysia";
import { mkdir, writeFile, rm } from "node:fs/promises";
import { join, extname } from "node:path";
import { unzipSync } from "fflate";
import { ChapterStore } from "../../stores/chapter-store";
import { PageStore } from "../../stores/page-store";
import { envConfig } from "../../env-config";
import { catchError, catchErrorSync } from "../../lib/error-handler";
import { generateUniqueFilename } from "./helpers";

/**
 * Chapters API endpoints
 */
export const chaptersApi = new Elysia({ prefix: "/chapters" })
  .get("/:slug", async ({ params }) => {
    const [error, chapter] = await catchError(
      ChapterStore.findBySlug(params.slug),
    );

    if (error) {
      console.error("Get chapter error:", error);
      return {
        success: false,
        error: error.message,
      };
    }

    if (!chapter) {
      return {
        success: false,
        error: "Chapter not found",
      };
    }

    return {
      success: true,
      chapter,
    };
  })
  .get("/:slug/pages", async ({ params }) => {
    // Find chapter by slug first
    const [chapterError, chapter] = await catchError(
      ChapterStore.findBySlug(params.slug),
    );

    if (chapterError) {
      console.error("Get chapter error:", chapterError);
      return {
        success: false,
        error: chapterError.message,
        pages: [],
      };
    }

    if (!chapter) {
      return {
        success: false,
        error: "Chapter not found",
        pages: [],
      };
    }

    const [pagesError, pages] = await catchError(
      PageStore.findByChapterId(chapter.id),
    );

    if (pagesError) {
      console.error("Get chapter pages error:", pagesError);
      return {
        success: false,
        error: pagesError.message,
        pages: [],
      };
    }

    return {
      success: true,
      pages,
    };
  })
  .post(
    "/",
    async ({ body }) => {
      const { seriesId: seriesIdStr, title, chapterNumber, zipFile } = body;
      const seriesId = parseInt(seriesIdStr);

      // Check if chapter number already exists for this series
      const [chaptersError, existingChapters] = await catchError(
        ChapterStore.findBySeriesId(seriesId),
      );

      if (chaptersError) {
        console.error("Find chapters error:", chaptersError);
        return {
          success: false,
          error: chaptersError.message,
        };
      }

      if (existingChapters.some((ch) => ch.chapterNumber === chapterNumber)) {
        return {
          success: false,
          error: `Chapter ${chapterNumber} already exists in this series`,
        };
      }

      // Create chapter (slug will be auto-generated by ChapterStore)
      const [createError, chapter] = await catchError(
        ChapterStore.create({
          seriesId,
          title,
          chapterNumber,
        }),
      );

      if (createError) {
        console.error("Create chapter error:", createError);
        return {
          success: false,
          error: createError.message,
        };
      }

      // Create chapter directory
      const chapterDir = join(
        envConfig.MANGA_DIR,
        seriesId.toString(),
        "chapters",
        chapter.id.toString(),
      );

      const [mkdirError] = await catchError(
        mkdir(chapterDir, { recursive: true }),
      );

      if (mkdirError) {
        console.error("Create directory error:", mkdirError);
        return {
          success: false,
          error: mkdirError.message,
        };
      }

      // Extract ZIP file
      const [zipError, zipBuffer] = await catchError(zipFile.arrayBuffer());

      if (zipError) {
        console.error("Read ZIP error:", zipError);
        return {
          success: false,
          error: zipError.message,
        };
      }

      const [unzipError, extracted] = catchErrorSync(() =>
        unzipSync(new Uint8Array(zipBuffer)),
      );

      if (unzipError) {
        console.error("Unzip error:", unzipError);
        return {
          success: false,
          error: unzipError.message,
        };
      }

      // Filter and sort image files
      const imageExtensions = [".jpg", ".jpeg", ".png", ".gif", ".webp"];
      const imageFiles: Array<{ name: string; data: Uint8Array }> = [];

      for (const [filename, data] of Object.entries(extracted)) {
        const ext = extname(filename).toLowerCase();
        if (imageExtensions.includes(ext)) {
          imageFiles.push({ name: filename, data: data as Uint8Array });
        }
      }

      // Sort images by filename (natural sort)
      imageFiles.sort((a, b) =>
        a.name.localeCompare(b.name, undefined, { numeric: true }),
      );

      if (imageFiles.length === 0) {
        // Delete chapter if no images found
        await catchError(ChapterStore.delete(chapter.id));
        return {
          success: false,
          error: "No valid image files found in ZIP",
        };
      }

      // Save images and create page records
      const pages = [];
      for (let i = 0; i < imageFiles.length; i++) {
        const imageFile = imageFiles[i];
        if (!imageFile) continue;

        const ext = extname(imageFile.name).replace(".", ""); // Remove leading dot
        const pageFilename = generateUniqueFilename(ext, i + 1);
        const pagePath = join(chapterDir, pageFilename);

        // Write image file
        const [writeError] = await catchError(
          writeFile(pagePath, imageFile.data),
        );

        if (writeError) {
          console.error("Write image error:", writeError);
          return {
            success: false,
            error: writeError.message,
          };
        }

        // Create page record
        const imagePath = `/uploads/${seriesId}/chapters/${chapter.id}/${pageFilename}`;
        const [pageError, page] = await catchError(
          PageStore.create({
            chapterId: chapter.id,
            originalImage: imagePath,
            orderNum: i + 1,
          }),
        );

        if (pageError) {
          console.error("Create page error:", pageError);
          return {
            success: false,
            error: pageError.message,
          };
        }

        pages.push(page);
      }

      return {
        success: true,
        chapter,
        pagesCount: pages.length,
      };
    },
    {
      body: t.Object({
        seriesId: t.String(), // FormData sends as string
        title: t.String(),
        chapterNumber: t.String(),
        zipFile: t.File(),
      }),
    },
  )
  .put(
    "/:slug",
    async ({ params, body }) => {
      // Find chapter by slug first
      const [findError, chapter] = await catchError(
        ChapterStore.findBySlug(params.slug),
      );

      if (findError) {
        console.error("Find chapter error:", findError);
        return {
          success: false,
          error: findError.message,
        };
      }

      if (!chapter) {
        return {
          success: false,
          error: "Chapter not found",
        };
      }

      const { title, chapterNumber } = body;

      const [updateError, updatedChapter] = await catchError(
        ChapterStore.update(chapter.id, {
          title,
          chapterNumber,
        }),
      );

      if (updateError) {
        console.error("Update chapter error:", updateError);
        return {
          success: false,
          error: updateError.message,
        };
      }

      if (!updatedChapter) {
        return {
          success: false,
          error: "Chapter not found",
        };
      }

      return {
        success: true,
        chapter: updatedChapter,
      };
    },
    {
      body: t.Object({
        title: t.String(),
        chapterNumber: t.String(),
      }),
    },
  )
  .delete("/:slug", async ({ params }) => {
    // Find chapter by slug first
    const [findError, chapter] = await catchError(
      ChapterStore.findBySlug(params.slug),
    );

    if (findError) {
      console.error("Find chapter error:", findError);
      return {
        success: false,
        error: findError.message,
      };
    }

    if (!chapter) {
      return {
        success: false,
        error: "Chapter not found",
      };
    }

    // Delete chapter folder and all its contents
    const chapterDir = join(
      envConfig.MANGA_DIR,
      chapter.seriesId.toString(),
      "chapters",
      chapter.id.toString(),
    );
    const [dirError] = await catchError(
      rm(chapterDir, { recursive: true, force: true }),
    );

    if (dirError) {
      // Folder might not exist, log but don't fail the deletion
      console.warn(
        `⚠️  Could not delete chapter folder for chapter ${chapter.id}`,
        dirError,
      );
    }

    // Delete database record (cascades to pages and captions)
    const [deleteError, deleted] = await catchError(
      ChapterStore.delete(chapter.id),
    );

    if (deleteError) {
      console.error("Delete chapter error:", deleteError);
      return {
        success: false,
        error: deleteError.message,
      };
    }

    if (!deleted) {
      return {
        success: false,
        error: "Failed to delete chapter",
      };
    }

    return {
      success: true,
    };
  });
