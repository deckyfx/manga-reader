import { Elysia, t, type Static } from "elysia";
import { mkdir, writeFile, rm } from "node:fs/promises";
import { join } from "node:path";
import { SeriesStore } from "../../stores/series-store";
import { ChapterStore } from "../../stores/chapter-store";
import { envConfig } from "../../env-config";
import { catchError } from "../../lib/error-handler";

/**
 * Series API schema definitions
 */
export const SeriesAPISchema = {
  getSeries: {
    query: t.Object({
      searchName: t.Optional(t.String()),
      hasChapters: t.Optional(t.Union([t.Boolean(), t.String()])),
      mustHaveTags: t.Optional(t.String()), // Comma-separated
      mustNotHaveTags: t.Optional(t.String()), // Comma-separated
    }),
  },
  createSeries: {
    body: t.Object({
      title: t.String(),
      synopsis: t.Optional(t.String()),
      tags: t.Optional(t.String()),
      coverArt: t.Optional(t.File({ type: "image" })),
    }),
  },
  updateSeries: {
    body: t.Object({
      title: t.String(),
      synopsis: t.Optional(t.String()),
      tags: t.Optional(t.String()),
      coverArt: t.Optional(t.File({ type: "image" })),
    }),
  },
} as const;

/**
 * Export inferred types
 */
export type GetSeriesQuery = Static<typeof SeriesAPISchema.getSeries.query>;
export type CreateSeriesBody = Static<typeof SeriesAPISchema.createSeries.body>;
export type UpdateSeriesBody = Static<typeof SeriesAPISchema.updateSeries.body>;

/**
 * Series API endpoints
 */
export const seriesApi = new Elysia({ prefix: "/series" })
  .get(
    "/",
    async ({ query }: { query: GetSeriesQuery }) => {
      // Parse filters from query parameters
      const filters: {
        searchName?: string;
        hasChapters?: boolean;
        mustHaveTags?: string[];
        mustNotHaveTags?: string[];
      } = {};

      // Parse searchName
      if (query.searchName) {
        filters.searchName = query.searchName;
      }

      // Parse hasChapters (handle both boolean and string)
      if (query.hasChapters === "true" || query.hasChapters === true) {
        filters.hasChapters = true;
      }

      // Parse mustHaveTags (comma-separated string to array)
      if (query.mustHaveTags) {
        filters.mustHaveTags = query.mustHaveTags
          .split(",")
          .map((tag) => tag.trim())
          .filter((tag) => tag.length > 0);
      }

      // Parse mustNotHaveTags (comma-separated string to array)
      if (query.mustNotHaveTags) {
        filters.mustNotHaveTags = query.mustNotHaveTags
          .split(",")
          .map((tag) => tag.trim())
          .filter((tag) => tag.length > 0);
      }

      // Use search method with filters
      const [error, seriesData] = await catchError(
        SeriesStore.search(filters),
      );

      if (error) {
        console.error("Get series error:", error);
        return {
          success: false,
          error: error.message,
          series: [],
        };
      }

      return {
        success: true,
        series: seriesData,
      };
    },
    {
      query: SeriesAPISchema.getSeries.query,
    },
  )
  .get("/:slug", async ({ params }) => {
    const [error, seriesData] = await catchError(
      SeriesStore.findBySlug(params.slug),
    );

    if (error) {
      console.error("Get series error:", error);
      return {
        success: false,
        error: error.message,
      };
    }

    if (!seriesData) {
      return {
        success: false,
        error: "Series not found",
      };
    }

    return {
      success: true,
      series: seriesData,
    };
  })
  .get("/:slug/chapters", async ({ params }) => {
    // Find series by slug first
    const [seriesError, series] = await catchError(
      SeriesStore.findBySlug(params.slug),
    );

    if (seriesError) {
      console.error("Get series error:", seriesError);
      return {
        success: false,
        error: seriesError.message,
        chapters: [],
      };
    }

    if (!series) {
      return {
        success: false,
        error: "Series not found",
        chapters: [],
      };
    }

    const [chaptersError, chapters] = await catchError(
      ChapterStore.findBySeriesId(series.id),
    );

    if (chaptersError) {
      console.error("Get chapters error:", chaptersError);
      return {
        success: false,
        error: chaptersError.message,
        chapters: [],
      };
    }

    return {
      success: true,
      chapters,
    };
  })
  .post(
    "/",
    async ({ body }: { body: CreateSeriesBody }) => {
      const { title, synopsis, tags, coverArt } = body;

      // Parse tags if provided (store as comma-separated string)
      const tagsCleaned = tags
        ? tags.split(",").map((tag: string) => tag.trim()).join(",")
        : null;

      // Create series (slug will be auto-generated by SeriesStore)
      const [createError, newSeries] = await catchError(
        SeriesStore.create({
          title,
          synopsis: synopsis || null,
          coverArt: null,
          tags: tagsCleaned,
        }),
      );

      if (createError) {
        console.error("Create series error:", createError);
        return {
          success: false,
          error: createError.message,
        };
      }

      // Handle cover art upload after getting series ID
      if (coverArt) {
        const ext = coverArt.name.split(".").pop() || "jpg";
        const filename = `cover.${ext}`;

        // Use environment-aware manga directory
        const seriesDir = join(envConfig.MANGA_DIR, newSeries.id.toString());
        const coversDir = join(seriesDir, "covers");
        const coverPath = join(coversDir, filename);

        const [mkdirError] = await catchError(
          mkdir(coversDir, { recursive: true }),
        );

        if (mkdirError) {
          console.error("Create directory error:", mkdirError);
          return {
            success: false,
            error: mkdirError.message,
          };
        }

        const [bufferError, buffer] = await catchError(
          coverArt.arrayBuffer(),
        );

        if (bufferError) {
          console.error("Read cover art error:", bufferError);
          return {
            success: false,
            error: bufferError.message,
          };
        }

        const [writeError] = await catchError(
          writeFile(coverPath, new Uint8Array(buffer)),
        );

        if (writeError) {
          console.error("Write cover art error:", writeError);
          return {
            success: false,
            error: writeError.message,
          };
        }

        // Update series with cover art path (relative to public directory)
        const coverArtPath = `/uploads/${newSeries.id}/covers/${filename}`;
        const [updateError, updated] = await catchError(
          SeriesStore.update(newSeries.id, {
            coverArt: coverArtPath,
          }),
        );

        if (updateError) {
          console.error("Update series error:", updateError);
          return {
            success: false,
            error: updateError.message,
          };
        }

        if (updated) {
          newSeries.coverArt = coverArtPath;
        }
      }

      return {
        success: true,
        series: newSeries,
      };
    },
    {
      body: SeriesAPISchema.createSeries.body,
    },
  )
  .put(
    "/:slug",
    async ({ params, body }: { params: { slug: string }; body: UpdateSeriesBody }) => {
      // Find series by slug first
      const [findError, series] = await catchError(
        SeriesStore.findBySlug(params.slug),
      );

      if (findError) {
        console.error("Find series error:", findError);
        return {
          success: false,
          error: findError.message,
        };
      }

      if (!series) {
        return {
          success: false,
          error: "Series not found",
        };
      }

      const seriesId = series.id;
      const { title, synopsis, tags, coverArt } = body;

      // Parse tags if provided (store as comma-separated string)
      const tagsCleaned = tags
        ? tags.split(",").map((tag: string) => tag.trim()).join(",")
        : null;

      // Handle cover art upload
      let coverArtPath: string | null | undefined = undefined;
      if (coverArt) {
        const ext = coverArt.name.split(".").pop() || "jpg";
        const filename = `cover.${ext}`;

        // Use environment-aware manga directory
        const seriesDir = join(envConfig.MANGA_DIR, seriesId.toString());
        const coversDir = join(seriesDir, "covers");
        const coverPath = join(coversDir, filename);

        const [mkdirError] = await catchError(
          mkdir(coversDir, { recursive: true }),
        );

        if (mkdirError) {
          console.error("Create directory error:", mkdirError);
          return {
            success: false,
            error: mkdirError.message,
          };
        }

        const [bufferError, buffer] = await catchError(
          coverArt.arrayBuffer(),
        );

        if (bufferError) {
          console.error("Read cover art error:", bufferError);
          return {
            success: false,
            error: bufferError.message,
          };
        }

        const [writeError] = await catchError(
          writeFile(coverPath, new Uint8Array(buffer)),
        );

        if (writeError) {
          console.error("Write cover art error:", writeError);
          return {
            success: false,
            error: writeError.message,
          };
        }

        // Store path relative to public directory
        coverArtPath = `/uploads/${seriesId}/covers/${filename}`;
      }

      const updateData: any = {
        title,
        synopsis: synopsis || null,
        tags: tagsCleaned,
      };

      // Only update coverArt if a new file was uploaded
      if (coverArtPath !== undefined) {
        updateData.coverArt = coverArtPath;
      }

      const [updateError, updatedSeries] = await catchError(
        SeriesStore.update(seriesId, updateData),
      );

      if (updateError) {
        console.error("Update series error:", updateError);
        return {
          success: false,
          error: updateError.message,
        };
      }

      if (!updatedSeries) {
        return {
          success: false,
          error: "Series not found",
        };
      }

      return {
        success: true,
        series: updatedSeries,
      };
    },
    {
      body: SeriesAPISchema.updateSeries.body,
    },
  )
  .delete("/:slug", async ({ params }) => {
    // Find series by slug first
    const [findError, series] = await catchError(
      SeriesStore.findBySlug(params.slug),
    );

    if (findError) {
      console.error("Find series error:", findError);
      return {
        success: false,
        error: findError.message,
      };
    }

    if (!series) {
      return {
        success: false,
        error: "Series not found",
      };
    }

    // Delete entire series folder (includes all chapters, pages, and cover art)
    const seriesDir = join(envConfig.MANGA_DIR, series.id.toString());
    const [dirError] = await catchError(
      rm(seriesDir, { recursive: true, force: true }),
    );

    if (dirError) {
      // Folder might not exist, log but don't fail the deletion
      console.warn(
        `⚠️  Could not delete series folder for series ${series.id}`,
        dirError,
      );
    }

    // Delete database record (cascades to chapters, pages, and captions)
    const [deleteError, deleted] = await catchError(
      SeriesStore.delete(series.id),
    );

    if (deleteError) {
      console.error("Delete series error:", deleteError);
      return {
        success: false,
        error: deleteError.message,
      };
    }

    if (!deleted) {
      return {
        success: false,
        error: "Failed to delete series",
      };
    }

    return {
      success: true,
    };
  });
